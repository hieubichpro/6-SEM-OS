/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */
#include <pthread.h>
#include <unistd.h>
#include "bakery.h"
struct thread_arg {
	int pid;
	int num;
	char res;
};
pthread_attr_t attr[32];
pthread_t thr[32];
struct thread_arg res[32];
int choosing[32] = {0};
int number[32] = {0};
int num = 0;
char c = 'a';
struct BAKERY *
get_number_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
	static struct BAKERY  result;
	int ind = num++, max = 0;
	choosing[ind] = 1;
	for (int i = 0; i < 32; i++)
		if (number[i] > max)
			max = number[i];
	number[ind] = max + 1;
	argp->pid = ind;
	argp->num = number[ind];
	choosing[ind] = 0;
	result.pid = ind;
	result.num = number[ind];
	return &result;
}
void *
bakery_service(void *arg)
{
	struct thread_arg *targ = arg;
	int i = targ->pid;
	sleep(10);
	for (int j = 0; j < 32; j++)
	{
		while (choosing[j]) {};
		while (number[j] != 0 && (number[j] < number[i] || (number[j] == number[i] && j < i))) {};
	}
	targ->res = c++;
	if (c > 'z')
		c = 'a';
	printf("Client id = %d, num = %d, res = %c\n", targ->pid, targ->num, targ->res);
	number[i] = 0;
	return 0;
}
struct BAKERY *
bakery_wait_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
	static struct BAKERY  result;
	int s;
	s = pthread_attr_init(&attr[argp->pid]);
	if (s != 0)
	{
		perror("pthread_attr_init");
		exit(1);
	}
	res[argp->pid].pid = argp->pid;
	res[argp->pid].num = argp->num;
	s = pthread_create(&thr[argp->pid], &attr[argp->pid], bakery_service, &res[argp->pid]);
	if (s != 0)
	{
		perror("pthread_create");
		exit(1);
	}
	return &result;
}
struct BAKERY *
bakery_service_1_svc(struct BAKERY *argp, struct svc_req *rqstp)
{
	static struct BAKERY  result;
	int s;
	s = pthread_attr_destroy(&attr[argp->pid]);
	if (s != 0)
	{
		perror("pthread_attr_destroy");
		exit(1);
	}
	s = pthread_join(thr[argp->pid], NULL);
	if (s != 0)
	{
		perror("pthread_join");
		exit(1);
	}
	result.res = res[argp->pid].res;
	return &result;
}




